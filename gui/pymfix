#!/usr/bin/env python

"""The pymfix script starts mfix from Python, with a web server running for
interactive control of the run."""

import getopt
import json
import logging
import numpy.core
import os
import packaging
import packaging.requirements
import packaging.specifiers
import packaging.version
import random
import socket
import string
import sys
import tempfile
import threading
import time
import traceback

from timeit import default_timer as timer
from functools import wraps
from flask import Flask, render_template, request, redirect, url_for

sys.path.append(os.getcwd())
pidfile = None

# append the path of the symlink __file__ (not its realpath)
sys.path.append(os.path.dirname(__file__))

# Fortran modules are in uppercase since Fortran uses uppercase (even though it's
# conventional to only use uppercase for constants)
from mfix import compar as COMPAR
from mfix import des_time_march as DES_TIME_MARCH
from mfix import discretelement as DEM
from mfix import iterate as ITERATE
from mfix import main as MAIN
from mfix import residual as RESIDUAL
from mfix import run as RUN
from mfix import step as STEP

PYMFIX_DIR = os.path.dirname(os.path.realpath(__file__))

FLASK_APP = Flask(__name__, static_folder=PYMFIX_DIR+'/static',
                  template_folder=PYMFIX_DIR+'/templates')
FLASK_APP.config['SECRET_KEY'] = \
            ''.join([random.choice(string.digits + string.ascii_letters)
            for x in range(0,64)])
FLASK_APP.config['TOKEN_NAME'] = 'x-pymfix-auth'
DEBUG = True

log = logging.getLogger('werkzeug')
logformat = logging.Formatter('pymfix: %(levelname)s %(message)s')
loghandler = logging.StreamHandler()
loghandler.setFormatter(logformat)
log.setLevel(logging.INFO)
log.addHandler(loghandler)
log.disabled = True

mfix_thread = None


def token_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        client_token = request.headers.get(FLASK_APP.config['TOKEN_NAME'])
        server_token = FLASK_APP.config['SECRET_KEY']
        if client_token == server_token:
            return f(*args, **kwargs)
        else:
            return "Authentication required", 401, \
                  {'Content-Type': 'text/plain; charset=utf-8'}
    return decorated_function

def main():
    """The main function starts MFIX on a separate thread, then
       start the Flask server. """

    paused, port, keyword_args = parse_command_line_arguments()

    global mfix_thread
    mfix_thread = Mfix(paused, keyword_args, port=port)
    mfix_thread.start()

    def setup_ssl():
        # not too critical until remote host connections are supported
        # Use default cert/key, read commandline options, etc
        try:
            # intentionally break this for now
            #import ssl
            sslcert = sslkey = None
            sslcontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
            sslcontext.load_cert_chain(sslcert, sslkey)
            return True
        except:
            sslcontext = None
            return False

    protocol = 'https' if setup_ssl() else 'http'

    def _start_flask(host, port, debug, use_reloader):
        try:
            global pidfile
            pidfile = '%s.pid' % RUN.run_name.tobytes().strip().decode('utf-8')
            pidfile = 'DES_FB1.pid'
            with open(pidfile, 'w') as pid:
                pid.write('pid=%s\n' % (os.getpid(),))
                pid.write('url=%s://%s:%s\n' % (
                                    protocol, socket.gethostname(), port))
                pid.write('token=%s:%s\n' % (
                                    FLASK_APP.config['TOKEN_NAME'],
                                    FLASK_APP.config['SECRET_KEY']))
            log.debug('flask starting on port %d' % port)
            FLASK_APP.run(host='0.0.0.0',
                          port=port, debug=DEBUG,
                          use_reloader=False)

        except OSError as e:
            if user_port_specified:
                log.error('Specified port (%s) is unavailable' % port)
                os.remove(pidfile)
                raise e
            if e.errno == errno.EADDRINUSE:
                os.remove(pidfile)
                print('cannot bind to port %d' % port)
                _start_flask(host='0.0.0.0',
                             port=random.randint(1025, 65536), debug=DEBUG,
                             use_reloader=False)

    # start the Flask server on rank 0
    if COMPAR.mype == 0:
        try:
            _start_flask(host='0.0.0.0',
                         port=port, debug=DEBUG,
                         use_reloader=False)
        except KeyboardInterrupt:
            traceback.print_exc()
            # If we get here, the user hit Ctrl-C to shutdown the server,
            # so we call _exit() to kill the run_mfix thread.
            os.remove(pidfile)
            os._exit(0)

    else:
        # nothing else for rank>0 to do
        mfix_thread.thread.join()


# FIXME: it would be make sense to subclass Thread
class Mfix(object):
    " Class to represent the running instance of MFIX "

    requests = {}
    responses = {}

    def __init__(self, paused, keyword_args, port):
        " constructor "
        self.keyword_args = keyword_args
        self.thread = None
        self.status = json.dumps({})
        self.stopped = False
        self.paused = paused
        self.port = port
        self.t0 = 0.
        self.walltime = 0.
        self.walltime_remaining = 'unknown'
        self.time_step_init_walltime = 'unknown'
        self.time_step_end_walltime = 'unknown'
        self.do_iteration_walltime = 'unknown'
        self.des_time_init_walltime = 'unknown'
        self.des_time_steps_walltime = 'unknown'
        self.des_time_end_walltime = 'unknown'

    def start(self):
        " start the MFIX thread"
        self.thread = threading.Thread(target=self.run_mfix, kwargs={"keyword_args":self.keyword_args})
        self.thread.start()
        # wait for the MFIX thread to initialize COMPAR.mype
        time.sleep(0.1)

    def run_mfix(self, keyword_args=None):
        "Main thread for running MFIX itself"

        RUN.interactive = True

        for arg in keyword_args:
            MAIN.add_command_line_keyword(arg)

        MAIN.initialize()

        self.t0 = float(RUN.time)

        self.update_status()

        if DEM.discrete_element and not DEM.des_continuum_coupled:
            if RUN.dem_solids:
                self.dem_time_march()
            if RUN.pic_solids:
                DEM.pic_time_march()
        else:

            while not self.stopped:
                self.check_requests()
                iteration_start = timer()
                self.do_step()
                self.walltime += float(timer() - iteration_start)
                if RUN.tstop <= RUN.time + 0.1*RUN.dt:
                    self.walltime_remaining = str(0.)
                    self.paused = True
                elif RUN.time > self.t0:
                    self.walltime_remaining = str(self.walltime * (RUN.tstop/(RUN.time-self.t0) - 1))

                if RUN.steady_state:
                    break

        MAIN.finalize()

    def do_step(self):
        "Run one timestep"
        start = timer()
        STEP.time_step_init()
        self.time_step_init_walltime = float(timer() - start)

        step_incomplete = True
        while step_incomplete:
            ITERATE.iterate_init()
            while ITERATE.nit < ITERATE.max_nit and not (ITERATE.converged or ITERATE.diverged):
                ITERATE.nit = ITERATE.nit + 1
                start = timer()
                ITERATE.do_iteration()
                self.do_iteration_walltime = float(timer() - start)
                self.check_requests()

            ITERATE.post_iterate()

            step_incomplete = ITERATE.adjustdt() and not RUN.steady_state

        STEP.check_low_dt()
        STEP.chem_mass()

        if RUN.dem_solids:
            start = timer()
            DES_TIME_MARCH.des_time_init()
            self.des_time_init_walltime = float(timer() - start)

            self.dem_time_march()

            start = timer()
            DES_TIME_MARCH.des_time_end()
            self.des_time_end_walltime = float(timer() - start)

        start = timer()
        STEP.time_step_end()
        self.time_step_end_walltime = float(timer() - start)

    def dem_time_march(self):
        "Run DEM timesteps "
        start = timer()
        for ii in range(DES_TIME_MARCH.factor):
            print("DEM timestep %d / %d" % (ii, DES_TIME_MARCH.factor))
            DES_TIME_MARCH.des_time_step(ii)
            self.check_requests()
        self.des_time_steps_walltime = float(timer() - start)

    def update_status(self):
        """save status as JSON """

        output = {}
        output['paused'] = self.paused
        output['time'] = float(RUN.time)
        output['tstop'] = float(RUN.tstop)
        output['dt'] = float(RUN.dt)
        output['walltime_elapsed'] = self.walltime
        output['walltime_remaining'] = self.walltime_remaining
        output['profiling'] = (('time_step_init', self.time_step_init_walltime),
                               ('do_iteration', int(ITERATE.nit), self.do_iteration_walltime),
                               ('time_step_end', self.time_step_end_walltime),
                               ('des_time_init', self.des_time_init_walltime),
                               ('des_time_steps', int(DES_TIME_MARCH.factor), self.des_time_steps_walltime),
                               ('des_time_end', self.des_time_end_walltime))
        output['nit'] = int(ITERATE.nit)
        output['residuals'] = []
        if RESIDUAL.group_resid:
            for res_id in range(len(RESIDUAL.resid_grp_string)):
                output['residuals'].append((str(RESIDUAL.get_resid_grp_string(res_id)),
                                            str(RESIDUAL.get_resid_grp(res_id))))
        else:
            for res_id in range(len(RESIDUAL.resid_string)):
                output['residuals'].append((str(RESIDUAL.get_resid_string(res_id)),
                                            str(RESIDUAL.get_resid(res_id))))

        self.status = json.dumps(output)


    def check_requests(self):
        "check for requests sent by the Flask thread"

        while True:
            if self.requests:
                # requests would only arrive at rank 0
                req_id, cmd_args = self.requests.popitem()
            else:
                # command is empty for rank>0, or when rank 0 hasn't received anything
                req_id = None
                cmd_args = (None, None)

            json_cmd_args = json.dumps(cmd_args)
            # broadcast command from rank 0 to all ranks
            json_cmd_args = MAIN.do_mpi_bcast(json_cmd_args)
            json_cmd_args = json_cmd_args.tostring().rstrip()
            json_cmd_args = json_cmd_args.decode('utf-8')
            command, args = json.loads(json_cmd_args)

            if command:
                cmd = command.split(' ')[0].lower().strip()

                if hasattr(self, cmd):
                    self.responses[req_id] = getattr(self, cmd)(args)
                else:
                    self.responses[req_id] = 500, 'UNRECOGNIZED COMMAND\n'
            self.update_status()
            if not self.paused:
                return

            # loop until unpaused
            time.sleep(0.1)

    def unpause(self, _):
        " unpause "
        self.paused = False
        return 200, "UNPAUSING MFIX"

    def pause(self, _):
        " paused "
        self.paused = True
        return 200, "PAUSING MFIX"

    def write_dbg_vt(self, _):
        " call write_dbg_vtu_and_vtp_files "
        MAIN.do_write_dbg_vtu_and_vtp_files()
        return 200, 'Calling WRITE_DBG_VTU_AND_VTP_FILES\n'

    def backupres(self, _):
        " backup resource files"
        MAIN.do_backupres()
        return 200, 'BACKING UP RESOURCE FILES\n'

    def reinit(self, _):
        " reinitialize "
        MAIN.do_reinit(_.get('filename', None))
        return 200, 'REINITIALIZING MFIX\n'

    def exit(self, _):
        " run_mfix thread should exit cleanly "
        self.stopped = True
        return 200, 'EXITING MFIX\n'

    def abort(self, _):
        " exit abruptly"
        MAIN.do_abort()
        # should never get here
        return 200, 'ABORTING MFIX\n'

    def step(self, args):
        " take one or more timesteps "
        stepcount = int(args.get('stepcount', None)[0])
        if RUN.tstop <= RUN.time:
            RUN.tstop = RUN.tstop + stepcount*RUN.dt
        for _ in range(stepcount):
            self.do_step()
        return 200, 'DOING %s TIMESTEP(S)\n' % stepcount

    def get(self, args):
        " return the value of a variable in MFIX"

        mod = args.get('modname')
        var = args.get('varname')
        elem = args.get('elem', None)
        ids = args.get('ids', None)

        # slow things down for development
        time.sleep(COMPAR.mype)

        log = logging.getLogger(__name__)
        if var:
            if ids and len(ids.split(' ')) > 3:
                log.info("GOING TO GET IDS %s", var)
                # FIXME
                # ii, jj, kk, i2, j2, k2 = command.split(' ')[3:9]
                # for i in range(int(ii), int(i2)+1):
                #     for j in range(int(jj), int(j2)+1):
                #         for k in range(int(kk), int(k2)+1):
                #             if self.is_on_mype_owns(i, j, k):
                #                 eval_string = ('%s[%d]' % (var, self.funijk(i, j, k)))
                #                 log.info("GOING TO EXECUTE: %s" % eval_string)
                #                 # eval(eval_string) # FIXME
                #                 log.info(COMPAR.mype, "set for", i, j, k, self.funijk(i, j, k))
                #             else:
                #                 log.info(COMPAR.mype, "not on", i, j, k, self.funijk(i, j, k))
            else:
                log.info("GOING TO EVALUATE %s", var)
                try:
                    import mfix
                    val = getattr(getattr(mfix, mod), var)
                    try:
                        # give the full array if the client is asking for an array (not recommended)
                        val = val.tolist()
                    except:
                        pass
                    if elem:
                        elem = int(elem)
                        val = val[elem]
                    return 200, str(val)
                except AttributeError:
                    traceback.print_exc()
                    # TODO: use error code for REST call
                    val = "ERROR: could not evaluate "+var
                    return 400, val

    def set(self, args):
        " set a variable in MFIX "

        mod = args.get('modname')
        var = args.get('varname')
        elem = args.get('elem', None)
        val = args.get('varvalue', None)
        ids = args.get('ids', None)

        # slow things down for development
        time.sleep(COMPAR.mype)

        log = logging.getLogger(__name__)
        if var and val:
            if ids and len(ids.split(' ')) > 3:
                log.info("GOING TO SET IDS %s = %s" % (var, val))
                #FIXME
                # ii, jj, kk, i2, j2, k2 = command.split(' ')[3:9]
                # for i in range(int(ii), int(i2)+1):
                #     for j in range(int(jj), int(j2)+1):
                #         for k in range(int(kk), int(k2)+1):
                #             if self.is_on_mype_owns(i, j, k):
                #                 exec_string = ('%s[%d] = %s' % (var, self.funijk(i, j, k), val))
                #                 log.info("GOING TO EXECUTE: %s" % exec_string)
                #                 # exec(exec_string) # FIXME
                #                 log.info(COMPAR.mype, " set value for", i, j, k, self.funijk(i, j, k))
                #             else:
                #                 log.info(COMPAR.mype, "does not own", i, j, k, self.funijk(i, j, k))
            else:
                log.info("GOING TO SET %s.%s = %s", mod, var, val)
                try:
                    import mfix
                    mfix_mod = getattr(mfix, mod)
                    if elem:
                        elem = int(elem)
                        listvar = getattr(mfix_mod, var)
                        val = float(val[0])
                        listvar[elem] = val
                    else:
                        setattr(mfix_mod, var, val)
                    return 200, 'ok, I set %s to %s\n' % (var, val)
                except AttributeError:
                    # TODO: better error code REST response
                    return 500, 'ERROR could not set: %s to %s\n' % (var, val)

                log.info('ok, I set %s to %s\n', var, val)
        else:
            return 500, 'could not set %s to %s\n' % (var, val)

    # def funijk(self, i, j, k):
    #     "reimplement FUNIJK in Python"
    #     return COMPAR.ijk_array_of[i, j, k]

    # def is_on_mype_owns(self, li, lj, lk):
    #     "reimplement IS_ON_MYPE_OWNS in Python"
    #     is_owner = li >= COMPAR.istart and li <= COMPAR.iend and lj >= COMPAR.jstart \
    #                and lj <= COMPAR.jend and lk >= COMPAR.kstart and lk <= COMPAR.kend
    #     return is_owner

    def do_command(self, cmd, args=None):
        "Puts a command that was received over the web interface on the queue"
        req_id = threading.current_thread().ident
        self.requests[req_id] = (cmd, args)
        while req_id not in self.responses:
            time.sleep(0.1)
        resp = self.responses[req_id]
        del self.responses[req_id]

        return resp


# Route that will process the file upload
@FLASK_APP.route('/upload', methods=['POST'])
@token_required
def upload():
    "upload a new mfix.dat file and then reinitialize"
    # Get the name of the uploaded file

    if not request.files['file']:
        return "Error, need to upload file when doing reinit.", \
            400, {'Content-Type': 'text/plain; charset=utf-8'}

    # mfix.dat.upload.* files are not used by pymfix, but are for the user's
    # benefit to keep track of mfix.dat changes when doing multiple reinits
    # during a run
    if COMPAR.mype == 0:
        upload_file = open('mfix.dat.upload.%s' % int(time.time()), 'w')
        request.files['file'].save(upload_file)
        upload_file.close()

    tmp = tempfile.NamedTemporaryFile(delete=False, dir=os.getcwd())
    request.files['file'].save(tmp)
    status_code, data = mfix_thread.do_command("REINIT", args={'filename':tmp.name})
    os.unlink(tmp.name)

    if status_code != 200:
        return data

    return redirect(url_for('index'))


@FLASK_APP.route('/')
@token_required
def index():
    "renders pymfix web interface"
    return render_template('index.html', mfixdat_filename=request.args.get('filename', ''))


@FLASK_APP.route('/set/<modname>/<varname>', methods=['POST'])
@token_required
def set_variable(modname, varname):
    "sets a variable"
    args = dict(request.form)
    args['modname'] = modname
    args['varname'] = varname
    status_code, data = mfix_thread.do_command("SET", args=args)
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@FLASK_APP.route('/set/<modname>/<varname>/<elem>', methods=['POST'])
@token_required
def set_variable_array(modname, varname, elem):
    "sets a variable"
    args = dict(request.form)
    args['modname'] = modname
    args['varname'] = varname
    args['elem'] = elem
    status_code, data = mfix_thread.do_command("SET", args=args)
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@FLASK_APP.route('/get/<modname>/<varname>', methods=['GET'])
@token_required
def get_variable(modname, varname):
    "retrieves a variable"
    args = dict(request.args)
    args['modname'] = modname
    args['varname'] = varname
    status_code, data = mfix_thread.do_command("GET", args=args)
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@FLASK_APP.route('/get/<modname>/<varname>/<elem>', methods=['GET'])
@token_required
def get_variable_array(modname, varname, elem):
    "retrieves a variable"
    args = dict(request.args)
    args['modname'] = modname
    args['varname'] = varname
    args['elem'] = elem
    status_code, data = mfix_thread.do_command("GET", args=args)
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}


@FLASK_APP.route('/write_dbg_vt', methods=['POST'])
@token_required
def write_dbg_vt():
    "calls WRITE_DBG_VTU_AND_VTP_FILES"
    status_code, data = mfix_thread.do_command("WRITE_DBG_VT")
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}


@FLASK_APP.route('/backupres', methods=['POST'])
@token_required
def backupres():
    "calls BACKUP_RES"
    status_code, data = mfix_thread.do_command("BACKUPRES")
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}


@FLASK_APP.route('/exit', methods=['POST'])
@token_required
def exit_mfix():
    "exits the main loop in run_mfix"
    status_code, data = mfix_thread.do_command("EXIT")
    time.sleep(int(request.form['timeout'])) # wait for MFIX thread to end
    global pidfile
    os.remove(pidfile)
    os._exit(0)
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}


@FLASK_APP.route('/abort', methods=['POST'])
@token_required
def abort():
    "calls MFIX_EXIT"
    status_code, data = mfix_thread.do_command("ABORT")
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}


@FLASK_APP.route('/step', methods=['POST'])
@token_required
def step():
    "runs mfix for one timestep, regardless of TIME and TSTOP"
    args = dict(request.form)
    status_code, data = mfix_thread.do_command("STEP", args=args)
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}


@FLASK_APP.route('/pause', methods=['PUT'])
@token_required
def pause():
    "pauses MFIX if unpaused"
    status_code, data = mfix_thread.do_command("PAUSE")
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}


@FLASK_APP.route('/unpause', methods=['PUT'])
@token_required
def unpause():
    "unpause MFIX if paused"
    status_code, data = mfix_thread.do_command("UNPAUSE")
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@FLASK_APP.route('/status', methods=['GET'])
@token_required
def get_status():
    "returns current status: paused state, current time, and residuals"
    status_code = 200
    return str(mfix_thread.status), status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@FLASK_APP.route('/logging/<state>', methods=['POST'])
@FLASK_APP.route('/logging/<state>/<level>', methods=['POST'])
@token_required
def set_logging(state=None, level=None):
    """toggle Flask logging"""
    if state == 'enable':
        log.disabled = False
    if state == 'disable':
        log.disabled = True
    # maybe handle loglevel someday
    return 'OK', 200, {'Content-Type': 'text/plain; charset=utf-8'}


def parse_command_line_arguments():
    "handle command line arguments"
    port = random.randint(1025, 65536)
    usage_string = "\n".join(["Usage: pymfix [-f, --file <mfix.dat>]",
                              "              [-h, --help]",
                              "              [-p, --print-flags]",
                              "              [-P, --port <port>]",
                              "              [-s, --start]",
                              "              [<keyword>=<keywordvalue> ...]"])
    try:
        opts, keyword_args = getopt.getopt(sys.argv[1:],
                                           "f:hspP:",
                                           ["port=", "file=", "help", "start", "print-flags"])
    except getopt.GetoptError:
        print(usage_string)
        sys.exit(1)

    mfix_paused = True
    for opt, arg in opts:
        if opt in ("-f", "--file"):
            # Fortran strings need to be padded with blanks (ljust)
            MAIN.mfix_dat = arg.ljust(len(MAIN.mfix_dat))
        elif opt in ("-h", "--help"):
            print(usage_string)
            sys.exit(0)
        elif opt in ("-s", "--start"):
            mfix_paused = False
        elif opt in ("-p", "--print-flags"):
            MAIN.print_flags()
            sys.exit(1)
        elif opt in ("-P", "--port"):
            port = arg
            try:
                port = int(port)
                user_port_specified = True
                if port < 1025 or port > 65536:
                    raise ValueError
            except ValueError:
                print("Invalid port: %d", port)
                sys.exit(1)

    if len(keyword_args) > len(MAIN.cmd_line_args):
        print("Too many command line arguments: %d" % len(keyword_args))
        print("Only %d or fewer command line arguments are supported." % len(MAIN.cmd_line_args))
        sys.exit(1)

    return mfix_paused, port, keyword_args

if __name__ == '__main__':
    main()
